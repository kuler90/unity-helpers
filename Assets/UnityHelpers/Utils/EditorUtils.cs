#if UNITY_EDITOR

using System;
using System.IO;
using System.Text;
using UnityEngine;
using UnityEditor;

namespace UnityHelpers.Utils
{
    public static class EditorUtils
    {
        // Player Prefs

#if UNITY_EDITOR_OSX
        [MenuItem("UnityHelpers/Show PlayerPrefs", false, 0)]
        public static void ShowPlayerPrefs()
        {
            EditorUtility.OpenWithDefaultApp(string.Format("~/Library/Preferences/unity.{0}.{1}.plist", PlayerSettings.companyName, PlayerSettings.productName));
        }
#endif
        [MenuItem("UnityHelpers/Сlean PlayerPrefs", false, 1)]
        public static void CleanPlayerPrefs()
        {
            PlayerPrefs.DeleteAll();
        }

        // Persistent Datа

        [MenuItem("UnityHelpers/Show Persistent Datа Path", false, 20)]
        public static void ShowPersistentDataPath()
        {
            EditorUtility.RevealInFinder(Application.persistentDataPath);
        }

        [MenuItem("UnityHelpers/Сlean Persistent Datа", false, 21)]
        public static void CleanPersistentDatа()
        {
            FileUtil.DeleteFileOrDirectory(Application.persistentDataPath);
        }

        // Scene Objects

        [MenuItem("UnityHelpers/Disconnect Selected Prefabs", false, 40)]
        public static void DisconnectSelectedPrefabs()
        {
            var newObjects = new System.Collections.Generic.List<GameObject>();
            while (Selection.gameObjects.Length > 0)
            {
                GameObject oldObject = Selection.gameObjects[0];
                int objectIndex = oldObject.transform.GetSiblingIndex();
                GameObject newObject = MonoBehaviour.Instantiate(oldObject, oldObject.transform.parent, false);
                newObject.name = oldObject.name;
                MonoBehaviour.DestroyImmediate(oldObject);
                newObject.transform.SetSiblingIndex(objectIndex);
                newObjects.Add(newObject);
            }
            Selection.objects = newObjects.ToArray();
        }

        // Generators

        [MenuItem("UnityHelpers/Generate unity constants", false, 60)]
        public static void GenerateUnityConstants()
        {
            // Try to find an existing file named "[Generated constants] K.cs" in the project 
            string[] filePaths = Directory.GetFiles(Application.dataPath, "[Generated constants] K.cs", SearchOption.AllDirectories);
            string filePath = filePaths.Length > 0 ? filePaths[0] : null;

            // Choose filePath if empty
            if (string.IsNullOrEmpty(filePath))
            {
                string directory = EditorUtility.OpenFolderPanel("Choose location for constants file", Application.dataPath, "");
                // Canceled choose? Do nothing.
                if (string.IsNullOrEmpty(directory))
                {
                    return;
                }
                filePath = Path.Combine(directory, "[Generated constants] K.cs");
            }

            // Write out our file
            using (var writer = new StreamWriter(filePath))
            {
                writer.WriteLine("// This file is auto-generated by UnityHelpers. Modifications are not saved.");
                writer.WriteLine();

                // Write out scenes
                writer.WriteLine("namespace K");
                writer.WriteLine("{");
                writer.WriteLine("\tpublic static class Scenes");
                writer.WriteLine("\t{");
                foreach (var scene in EditorBuildSettings.scenes)
                {
                    string sceneName = scene.path
                            .Replace("Assets/Scenes/", "")
                            .Replace("Assets/", "")
                            .Replace("/Scene", "/")
                            .Replace("Scene/", "/")
                            .Replace("." + Path.GetExtension(scene.path), "");
                    string scenePath = scene.path
                            .Replace("Assets/", "")
                            .Replace("." + Path.GetExtension(scene.path), "");
                    writer.WriteLine("\t\tpublic const string {0} = \"{1}\";", _ConvertToConstantName(sceneName), scenePath);
                }
                writer.WriteLine("\t}");

                // Write out the tags
                writer.WriteLine();
                writer.WriteLine("\tpublic static class Tags");
                writer.WriteLine("\t{");
                foreach (var tag in UnityEditorInternal.InternalEditorUtility.tags)
                {
                    writer.WriteLine("\t\tpublic const string {0} = \"{1}\";", _ConvertToConstantName(tag), tag);
                }
                writer.WriteLine("\t}");

                // Write out sorting layers
                writer.WriteLine();
                writer.WriteLine("\tpublic enum SortingLayers: int");
                writer.WriteLine("\t{");
                foreach (var layer in SortingLayer.layers)
                {
                    writer.WriteLine("\t\t{0} = {1},", _ConvertToConstantName(layer.name), layer.id);
                }
                writer.WriteLine("\t}");

                // Write out layers
                writer.WriteLine();
                writer.WriteLine("\tpublic enum Layers: int");
                writer.WriteLine("\t{");
                for (int i = 0; i < 32; i++)
                {
                    string layerName = UnityEditorInternal.InternalEditorUtility.GetLayerName(i);
                    if (!string.IsNullOrEmpty(layerName))
                    {
                        writer.WriteLine("\t\t{0} = {1},", _ConvertToConstantName(layerName), i);
                    }
                }
                writer.WriteLine("\t}");
                writer.WriteLine("}");
            }

            // Refresh Unity project explorer
            AssetDatabase.Refresh();
        }

        private static string _ConvertToConstantName(string str)
        {
            var sb = new StringBuilder();
            var strCharArray = str.ToCharArray();
            char lastPrintedChar = (char)0;
            for (int index = 0; index < strCharArray.Length; index++)
            {
                char currentChar = strCharArray[index];
                if (sb.Length > 0 || Char.IsLetter(currentChar))
                {
                    if (currentChar == '/' && index == strCharArray.Length - 1)
                    {
                        continue;
                    }
                    else if (lastPrintedChar != '_' && (currentChar == '/' || currentChar == '_'))
                    {
                        sb.Append('_');
                        lastPrintedChar = '_';
                    }
                    else if (Char.IsLetterOrDigit(currentChar))
                    {
                        sb.Append(currentChar);
                        lastPrintedChar = currentChar;
                    }
                }
            }
            return sb.ToString();
        }
    }
}

#endif